<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>A brief introduction to econometrics in Stan</title>
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">
  <meta name="description" content="This course provides an introduction to Bayesian modeling, and examples of the common techniques used in many fields of econometrics.">
  <meta name="generator" content="bookdown 0.3.5 and GitBook 2.6.7">

  <meta property="og:title" content="A brief introduction to econometrics in Stan" />
  <meta property="og:type" content="book" />
  
  
  <meta property="og:description" content="This course provides an introduction to Bayesian modeling, and examples of the common techniques used in many fields of econometrics." />
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="A brief introduction to econometrics in Stan" />
  
  <meta name="twitter:description" content="This course provides an introduction to Bayesian modeling, and examples of the common techniques used in many fields of econometrics." />
  

<meta name="author" content="James Savage">


<meta name="date" content="2017-06-19">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="intro.html">
<link rel="next" href="vsb.html">

<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />









<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>About</a></li>
<li class="chapter" data-level="1" data-path="intro.html"><a href="intro.html"><i class="fa fa-check"></i><b>1</b> An introduction to Stan</a><ul>
<li class="chapter" data-level="1.1" data-path="intro.html"><a href="intro.html#why-might-you-want-to-start-learning-bayesian-methods"><i class="fa fa-check"></i><b>1.1</b> Why might you want to start learning Bayesian methods?</a><ul>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#benefit-1-incorporating-knowledge-from-outside-the-data"><i class="fa fa-check"></i>Benefit 1: Incorporating knowledge from outside the data</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#benefit-2-combining-sources-of-information"><i class="fa fa-check"></i>Benefit 2: Combining sources of information</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#benefit-3-dealing-with-uncertainty-consistently-in-model-predictions"><i class="fa fa-check"></i>Benefit 3: Dealing with uncertainty consistently in model predictions</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#benefit-4-regularizing-richly-parameterized-models"><i class="fa fa-check"></i>Benefit 4: Regularizing richly parameterized models</a></li>
<li class="chapter" data-level="" data-path="intro.html"><a href="intro.html#benefit-5-doing-away-with-tests"><i class="fa fa-check"></i>Benefit 5: Doing away with tests</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="intro.html"><a href="intro.html#models-and-inference"><i class="fa fa-check"></i><b>1.2</b> Models and inference</a></li>
<li class="chapter" data-level="1.3" data-path="intro.html"><a href="intro.html#why-use-stan"><i class="fa fa-check"></i><b>1.3</b> Why use Stan?</a></li>
<li class="chapter" data-level="1.4" data-path="intro.html"><a href="intro.html#background-bayes-rule-likelihood-and-priors"><i class="fa fa-check"></i><b>1.4</b> Background: Bayes rule, likelihood and priors</a><ul>
<li class="chapter" data-level="1.4.1" data-path="intro.html"><a href="intro.html#likelihoodlog-likelihood"><i class="fa fa-check"></i><b>1.4.1</b> Likelihood/log likelihood</a></li>
<li class="chapter" data-level="1.4.2" data-path="intro.html"><a href="intro.html#so-what-does-the-likelhood-mean"><i class="fa fa-check"></i><b>1.4.2</b> So what does the likelhood mean?</a></li>
<li class="chapter" data-level="1.4.3" data-path="intro.html"><a href="intro.html#prior-distributions"><i class="fa fa-check"></i><b>1.4.3</b> Prior distributions</a></li>
<li class="chapter" data-level="1.4.4" data-path="intro.html"><a href="intro.html#bayes-rule"><i class="fa fa-check"></i><b>1.4.4</b> Bayes rule</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="intro.html"><a href="intro.html#hmc-and-betancourt"><i class="fa fa-check"></i><b>1.5</b> HMC and Betancourt</a></li>
<li class="chapter" data-level="1.6" data-path="intro.html"><a href="intro.html#a-tour-of-a-stan-program"><i class="fa fa-check"></i><b>1.6</b> A tour of a Stan program</a><ul>
<li class="chapter" data-level="1.6.1" data-path="intro.html"><a href="intro.html#a-hello-world-example"><i class="fa fa-check"></i><b>1.6.1</b> A hello world example</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="2" data-path="msw.html"><a href="msw.html"><i class="fa fa-check"></i><b>2</b> Modern Statistical Workflow</a><ul>
<li class="chapter" data-level="2.1" data-path="msw.html"><a href="msw.html#modern-statistical-workflow"><i class="fa fa-check"></i><b>2.1</b> Modern Statistical Workflow</a><ul>
<li class="chapter" data-level="2.1.1" data-path="msw.html"><a href="msw.html#example-a-simple-time-series-model-of-loan-repayments"><i class="fa fa-check"></i><b>2.1.1</b> Example: A simple time-series model of loan repayments</a></li>
<li class="chapter" data-level="2.1.2" data-path="msw.html"><a href="msw.html#step-1-writing-out-the-probability-model"><i class="fa fa-check"></i><b>2.1.2</b> Step 1: Writing out the probability model</a></li>
<li class="chapter" data-level="2.1.3" data-path="msw.html"><a href="msw.html#step-2-simulating-the-model-with-known-parameters"><i class="fa fa-check"></i><b>2.1.3</b> Step 2: Simulating the model with known parameters</a></li>
<li class="chapter" data-level="2.1.4" data-path="msw.html"><a href="msw.html#model-inspection"><i class="fa fa-check"></i><b>2.1.4</b> Model inspection</a></li>
<li class="chapter" data-level="2.1.5" data-path="msw.html"><a href="msw.html#taking-the-model-to-real-data"><i class="fa fa-check"></i><b>2.1.5</b> Taking the model to real data</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="msw.html"><a href="msw.html#tools-of-the-trade-borrowing-from-software-engineering"><i class="fa fa-check"></i><b>2.2</b> Tools of the trade: borrowing from software engineering</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="vsb.html"><a href="vsb.html"><i class="fa fa-check"></i><b>3</b> A more difficult model</a></li>
<li class="chapter" data-level="4" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><i class="fa fa-check"></i><b>4</b> Aggregate random coefficients logit: Bayesian estimation using Stan</a><ul>
<li class="chapter" data-level="4.1" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#a-generative-model-of-consumer-choice"><i class="fa fa-check"></i><b>4.1</b> A generative model of consumer choice</a><ul>
<li class="chapter" data-level="4.1.1" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#generating-aggregate-sales-data-from-the-model"><i class="fa fa-check"></i><b>4.1.1</b> Generating aggregate sales data from the model</a></li>
<li class="chapter" data-level="4.1.2" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#modeling-price"><i class="fa fa-check"></i><b>4.1.2</b> Modeling price</a></li>
<li class="chapter" data-level="4.1.3" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#estimating-the-model-from-aggregate-market-level-data"><i class="fa fa-check"></i><b>4.1.3</b> Estimating the model from aggregate market-level data</a></li>
</ul></li>
<li class="chapter" data-level="4.2" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#part-2-fake-data-simulation"><i class="fa fa-check"></i><b>4.2</b> Part 2: Fake data simulation</a></li>
<li class="chapter" data-level="4.3" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#part-3-writing-out-the-model-in-stan"><i class="fa fa-check"></i><b>4.3</b> Part 3: Writing out the model in Stan</a></li>
<li class="chapter" data-level="4.4" data-path="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html"><a href="aggregate-random-coefficients-logit-bayesian-estimation-using-stan.html#conclusion"><i class="fa fa-check"></i><b>4.4</b> Conclusion</a></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">A brief introduction to econometrics in Stan</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="msw" class="section level1">
<h1><span class="header-section-number">Session 2</span> Modern Statistical Workflow</h1>
<p>This session introduces the process I recommend for model building, which I call “Modern Statistical Workflow”.</p>
<div id="modern-statistical-workflow" class="section level2">
<h2><span class="header-section-number">2.1</span> Modern Statistical Workflow</h2>
<p>The workflow described here is a template for how to build high-quality, robust models. If you work by it, you will learn models more thoroughly, spot errors more swiftly, and build a much better understanding of economics and statistics than you would under a less rigorous workflow.</p>
<p>The workflow is iterative. Typically we start with the simplest possible model, working through each step in the process. Only once we have done each step do we add richness to the model. Building models up like this in an iterative way will mean that you always have a working version of a model to fall back on. The process is:</p>
<ol style="list-style-type: decimal">
<li>Write out a full probability model. This involves specifying the joint distribution for your parameters/latent variables and the conditional distribution for the outcome data.</li>
<li>Simulate some data from the model with assumed values for the parameters (these might be quite different from the “true” parameter values).</li>
<li>Estimate the model using the simulated data. Check that your model can recover the known parameters used to simulate the data.</li>
<li>Estimate the model parameters conditioned on real data.</li>
<li>Check that the estimation has run properly.</li>
<li>Run posterior predictive checking/time series cross validation to evaluate model fit.</li>
<li>Perform predictive inference.</li>
</ol>
<p>Iterate the entire process to improve the model! Compare models—which model are the observed outcomes more plausibly drawn from?</p>
<div id="example-a-simple-time-series-model-of-loan-repayments" class="section level3">
<h3><span class="header-section-number">2.1.1</span> Example: A simple time-series model of loan repayments</h3>
<p>Before building any model, it is always worth writing down the questions that we might want to ask. Sometimes, the questions will be relativey simple, like “what is the difference in average wages between men and women?” Yet for most large-scale modeling tasks we want to build models capable of answering many questions. In the case of wages, they may be questions like:</p>
<ul>
<li>If I know someone is male and lives in the South what should I expect their wages to be, holding other personal characteristics constant?</li>
<li>How much does education affect wages?</li>
<li>Workers with more work experience tend to earn higher wages. How does this effect vary across demographic groups?</li>
<li>Does variance in wages differ across demographic groups?</li>
</ul>
<p>As a good rule of thumb, the more questions you want a model to be able to answer, the more complex the model will have to be. The first question above might be answered with a simple linear regression model, the second, a more elaborate model that allows the relationship between experience and wages to vary across demographic groups; the final question might involve modeling the variance of the wage distribution, not just its mean.</p>
<p>The example given below introduces a simple autoregressive model of a daily KPI from a microfinance company. We’ll introduce an additional complexity—the fictitious client’s systems are unreliable, and for some days, there are missing values for the KPI.</p>
<p>Let’s walk through each step of the workflow, gradually introducing Stan along the way. First, let’s download the data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(readr)
<span class="co"># Download file from: </span>
<span class="co"># https://github.com/khakieconomics/half_day_course/blob/master/KPI_data.csv then</span>

KPI_data &lt;-<span class="st"> </span><span class="kw">read_csv</span>(<span class="st">&quot;KPI_data.csv&quot;</span>)</code></pre></div>
</div>
<div id="step-1-writing-out-the-probability-model" class="section level3">
<h3><span class="header-section-number">2.1.2</span> Step 1: Writing out the probability model</h3>
<p>The first step of of our workflow is to propose an underlying generative model. It’s helpful to think of a generative model as being a structured random number generator, which when simulated, generates outcomes with a distribution that looks like the distribution of the outcome variable. Once we have decided on the generative model, we then get into the specifics of endogeneity issues etc. In deciding the choice of distribution to use, you should plot a histogram or density of the outcome. For example, we could generate a histogram of the KPI like so:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ggplot2)
<span class="kw">ggplot</span>(KPI_data, <span class="kw">aes</span>(<span class="dt">x =</span> kpi_value)) +
<span class="st">  </span><span class="kw">geom_histogram</span>() +<span class="st"> </span>
<span class="st">  </span>ggthemes::<span class="kw">theme_hc</span>(<span class="dt">base_size =</span> <span class="dv">12</span>) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Histogram of KPI values&quot;</span>)</code></pre></div>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-14-1.png" width="672" /></p>
<p>We can also plot the time series</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ggplot2)

<span class="kw">ggplot</span>(KPI_data, <span class="kw">aes</span>(<span class="dt">x =</span> date, <span class="dt">y =</span> kpi_value)) +
<span class="st">  </span><span class="kw">geom_line</span>() +<span class="st"> </span>
<span class="st">  </span>ggthemes::<span class="kw">theme_hc</span>(<span class="dt">base_size =</span> <span class="dv">12</span>) +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Time series plot of KPI values&quot;</span>)</code></pre></div>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-15-1.png" width="672" /></p>
<p>As we can see, the KPI seems to have a bit of a bell-shaped curve, does not seem to be (locally) truncated, and is continuous. It’d make sense to choose a density from a family that has such characteristics, like:</p>
<ul>
<li>Normal</li>
<li>Student’s t</li>
<li>Cauchy</li>
<li>Gumbel</li>
</ul>
<p>If we decide to choose a normal density as the data-generating process, and assume that the conditional distribution is an autoregressive model with <span class="math inline">\(p\)</span> lags.</p>
<p><span class="math display">\[
\mbox{kpi}_{t} \sim \mbox{Normal}(\alpha + \beta_{1}\mbox{kpi}_{t-1} + \dots + \beta_{p}\mbox{kpi}_{t-p}, \sigma)
\]</span></p>
<p>which says that a the value of the KPI is distributed according to a normal distribution with <em>location</em> <span class="math inline">\(\alpha + \beta_{1}\mbox{kpi}_{t-1} + \dots + \beta_{p}\mbox{kpi}_{t-p}\)</span> and <em>scale</em> <span class="math inline">\(\sigma\)</span>. In the case of a normal density, the location is the mean, and the scale is the standard deviation. We prefer to use “location” and “scale” rather than “mean” and “standard deviation” because the terminology can carry across to other densities whose location and scale parameters don’t correspond to the mean or standard deviation.</p>
<p>The parameters of the generative model are both “true” and unknown. The entire point is to peform inference in order to get probabilistic estimates of the “true” parameters.</p>
<div id="choosing-the-right-generative-model" class="section level4">
<h4><span class="header-section-number">2.1.2.1</span> Choosing the right generative model</h4>
<p>Above, we picked out a normal density for the conditional distribution of the KPI. a reasonable first step in modeling our wage series. How did we get to this choice? The choice of distribution to use should depend on the nature of your outcome variables. Two good rules of thumb are:</p>
<ol style="list-style-type: decimal">
<li>The chosen distribution should not give positive probability to impossible outcomes. For example, wages can’t be negative, and so if we were to use a normal density (which gives positive probability to all outcomes) to model wages, we would be committing an error. If an outcome is outcome is binary or count data, the model should not give weight to non-integer outcomes. And so on.</li>
<li>The chosen distribution should give positive weight to plausible outcomes.</li>
</ol>
</div>
<div id="choosing-priors" class="section level4">
<h4><span class="header-section-number">2.1.2.2</span> Choosing priors</h4>
<p>To complete our probability model, we need to specify priors for the parameters <span class="math inline">\(\alpha\)</span>, <span class="math inline">\(\beta\)</span> and <span class="math inline">\(\sigma\)</span>. Again, these priors should place positive probabilistic weight over values of the parameters that we consider possible, and zero weight on impossible values (like a negative scale <span class="math inline">\(\sigma\)</span>). In this case, it is common to assume normal priors for regression coefficients and half-Cauchy or half-Student-t priors on scales.</p>
<p>A great discussion of choosing priors is available <a href="github.com/stan-dev/wiki">here</a>.</p>
<p>In this case, we don’t know how many lags to include. One approach is to use the so-called <em>Horseshoe prior</em>, a prior that shrinks coefficients on uninformative parameters very strongly towards zero, without having a large effect on the remaining coefficients. This is similar in spirit to LASSO or Ridge Regression.</p>
<p>The horseshoe prior is:</p>
<p><span class="math display">\[
\beta_{i} \sim \mbox{Normal}(0, \tau \lambda_{i})
\]</span> with</p>
<p><span class="math display">\[
\lambda_{i} \sim \mbox{Cauchy}_{+}(0, 1)
\]</span> And <span class="math inline">\(\tau\)</span> either provided by the modeler, or estimated. <span class="math inline">\(\tau\)</span> is the global shrinkage coefficient, and <span class="math inline">\(\lambda_{i}\)</span> will take large values when <span class="math inline">\(\beta_{i}\)</span> is non-zero, and small values otherwise.</p>
</div>
</div>
<div id="step-2-simulating-the-model-with-known-parameters" class="section level3">
<h3><span class="header-section-number">2.1.3</span> Step 2: Simulating the model with known parameters</h3>
<p>An extremely important step in the workflow is to simulate the model with known values for the unknowns. This mightn’t seem very useful when you’re working with simple models, but as your models become more complex, it’s an extremely step.</p>
<p>There are two broad approaches to simulating your model with known parameters. The first is to hard-code the parameter values. This is fairly straightforward, and may be prefered when some parameter combinations result in unidentifiable models but it’s hard to define priors that place zero weight on such parameter combinations. A classic case of this is with time-series models, for which some parameter combinations result in an explosive time-series, but those parameter combinations do not have natural priors that would constrain them to be stationary.</p>
<p>The second approach is more robust, but it applies to a smaller set of models. In this approach we draw values of the unknowns directly from the priors, and then simulate data. This approach has several large benefits. First, it helps you get a sense for how reasonable your priors are. Quite recently, some colleagues and I were playing around with latent variables in high-dimensioned classification models of the form</p>
<p><span class="math display">\[
y \sim \mbox{categorical}(\mbox{softmax}(\theta))
\]</span> where the softmax of <span class="math inline">\(\theta\)</span> is <span class="math inline">\(\frac{\exp(\theta)}{\sum\exp(\theta)}\)</span>. Let’s say that <span class="math inline">\(y\)</span> can take 100 values and we have a diffuse prior <span class="math inline">\(\theta \sim \mbox{normal}(0, 100)\)</span>. What does the distribution of probabilities look like for this process?</p>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-16-1.png" width="672" /></p>
<p>Unless you think that one outcome is certain and the others have probability zero, a <span class="math inline">\(\mbox{normal}(0, 100)\)</span> prior is clearly unreasonable. On the other hand, what if we were to use <span class="math inline">\(\mbox{normal}(0, 1)\)</span>?</p>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-17-1.png" width="672" /></p>
<p>This is a far more reasonable looking distribution of probabilities.</p>
<p>Let’s generate some known parameters and covariates and simulate our AR model.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">T &lt;-<span class="st"> </span><span class="dv">500</span>
alpha &lt;-<span class="st"> </span><span class="dv">0</span>
beta &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">0.3</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, .<span class="dv">6</span>)
sigma &lt;-<span class="st"> </span><span class="dv">1</span>  

Y_raw &lt;-<span class="st"> </span><span class="ot">NULL</span>

Y_raw[<span class="dv">1</span>:<span class="dv">6</span>] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">6</span>, alpha)
for(i in <span class="dv">7</span>:T) {
  Y_raw[i] &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>,  alpha +<span class="st"> </span>Y_raw[(i<span class="dv">-6</span>):(i<span class="dv">-1</span>)] %*%<span class="st"> </span>beta, sigma)
}

<span class="kw">plot.ts</span>(Y_raw)</code></pre></div>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-18-1.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set some values to NA (Stan doesn&#39;t like NA, so we use some weird number)</span>

Y_raw[<span class="kw">sample</span>(<span class="dv">1</span>:T,<span class="dv">20</span>)] &lt;-<span class="st"> </span><span class="ot">NA</span>

<span class="kw">plot.ts</span>(Y_raw)</code></pre></div>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-18-2.png" width="672" /></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Y_raw[<span class="kw">is.na</span>(Y_raw)] &lt;-<span class="st"> </span>-<span class="dv">9</span>

N_missing &lt;-<span class="st"> </span><span class="dv">20</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># In R:</span>
<span class="co"># Load necessary libraries and set up multi-core processing for Stan</span>
<span class="kw">options</span>(<span class="dt">warn=</span>-<span class="dv">1</span>, <span class="dt">message =</span>-<span class="dv">1</span>)
<span class="kw">library</span>(dplyr); <span class="kw">library</span>(ggplot2); <span class="kw">library</span>(rstan); <span class="kw">library</span>(reshape2)
<span class="kw">options</span>(<span class="dt">mc.cores =</span> parallel::<span class="kw">detectCores</span>())</code></pre></div>
<p>Next we write out our Stan model. This one is a little involved so let’s step through it slowly</p>
<pre><code>// saved as ar_model_missing_data.stan
data {
  int T; // number of observations
  int P; // number of lags
  int N_missing; // the number of missing values
  vector[T] Y_raw; // the time series
}
parameters {
  real alpha;
  vector[P] beta;
  vector&lt;lower = 0&gt;[P] lambda;
  real&lt;lower = 0&gt; tau;
  vector[N_missing] missing;
  real&lt;lower = 0&gt; sigma;
}
transformed parameters {
  vector[T] Y; // 
  matrix[T, P] X; // lags matrix
  {
    int count;
    count = 0;
    for(t in 1:T) {
      if(Y_raw[t] == -9) {
        count = count + 1;
        Y[t] = missing[count];
      } else {
        Y[t] = Y_raw[t];
      }
    }
  }
  
  for(t in 1:T) {
    if(t&lt;P) {
      X[t] = rep_row_vector(0, P);
    } else {
      X[t] = Y[(t-P):(t-1)]&#39;;
    }
  }
}
model {
  // priors
  
  lambda ~ cauchy(0, 1);
  tau ~ cauchy(0, 1);
  beta ~ normal(0, tau*lambda);
  sigma ~ cauchy(0, 1);
  
  // likelihood
  Y ~ normal(alpha + X*beta, sigma);
}</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## # In R
## 
## compiled_model &lt;- stan_model(&quot;ar_model_missing.stan&quot;)
## 
## data_list &lt;- list(T = T, 
##                   P = 6, 
##                   Y_raw = Y_raw, 
##                   N_missing = N_missing)
## 
## model &lt;- sampling(compiled_model,
##               data_list,
##               iter = 1000,
##               chains = 4)
## 
## print(model, pars = c(&quot;alpha&quot;, &quot;beta&quot;, &quot;sigma&quot;))</code></pre></div>
<p>We have now fit our model to the fake data. What has been estimated?</p>
<div id="what-do-these-fitted-objects-contain" class="section level4">
<h4><span class="header-section-number">2.1.3.1</span> What do these fitted objects contain?</h4>
<p>If you are accustomed to estimating models using ordinary least squares (OLS), maximum likelihood estimates (MLE), or the general method of moments (GMM), then you may expect point estimates for parameters: regression tables contain an estimate of the parameter along with some standard errors. Full Bayesian inference involves averaging over the uncertainty in parameter estimates, that is, the posterior distribution. For a point estimate, Bayesians typically use the mean of the posterior distribution, because it minimizes expected square error in the estimate; the posterior median minimizes expected absolute error.</p>
<p>For all but a few models, posterior distributions cannot be expressed analytically. Instead, numerical techniques involving simulation going under the general heading of Monte Carlo methods, are used to estimate quantities of interest by taking draws from the distribution in question.</p>
<p>Monte Carlo estimation is quite simple. Let’s say a parameter <span class="math inline">\(\theta\)</span> is distributed according to some distribution <span class="math inline">\(\mbox{Foo}(\theta)\)</span> for which we have no analytical formula, but from which we can simulate random draws. We want to draw statistical inferences using this distribution; we want its mean (expected value), standard deviation, median and other quantiles for posterior intervals, etc. The Monte Carlo method allows us to make these inferences by simply generating many (not necessarily independent) draws from the distribution and then calculating the statistic of interest from those draws. Because these draws are from the distribution of interest, they will tend to come from the higher probability regions of the distribution. For example, if 50% of the posterior probability mass is near the posterior mode, then 50% of the simulated draws (give or take sampling error) should be near the posterior mode.</p>
<p>For example, suppose we want to estimate the expectation of <span class="math inline">\(\mbox{Foo}(\theta)\)</span>, or in other words, the mean of a variable <span class="math inline">\(\theta\)</span> with distribution <span class="math inline">\(\mbox{Foo}(\theta)\)</span>. If we take <span class="math inline">\(M\)</span> random draws from <span class="math inline">\(\mbox{Foo}\)</span>, <span class="math display">\[
\theta^{(1)}, \ldots, \theta^{(M)} \sim \mbox{Foo}(),
\]</span> then we can estimate the expected value of <span class="math inline">\(\theta\)</span> (i.e., its posterior mean) as <span class="math display">\[
\mathbb{E}[\theta]
\approx
\frac{1}{M} \sum_{m=1}^{M} \theta^{(m)}.
\]</span></p>
<p>If the draws <span class="math inline">\(\theta^{(m)}\)</span> are independent, the result is a sequence of independent and identically distributed (i.i.d.) draws. The mean of a sequence of i.i.d. draws is governed by the central limit theorem, where the standard error on the estimates is given by the standard deviation divided by the square root of the number of draws. Thus standard error decreases as <span class="math inline">\(\mathcal{O}(\frac{1}{\sqrt{M}})\)</span> in the number of independent draws <span class="math inline">\(M\)</span>.</p>
<p>What makes Bayesian inference not only possible, but practical, is that almost all of the Bayesian inference for event probabilities, predictions, and parameter estimates can be expressed as expectations and carried out using Monte Carlo methods.</p>
<p>There is one hitch, though. For almost any practically useful model, not only will we not be able to get an analytical formula for the posterior, we will not be able to take independent draws. Fortunately, all is not lost, as we will be able to take identically distributed draws using a technique known as Markov chain Monte Carlo (MCMC). With MCMC, the draws from a Markov chain in which each draw <span class="math inline">\(\theta^{(m+1)}\)</span> depends (only) on the previous draw <span class="math inline">\(\theta^{(m)}\)</span>. Such draws are governed by the MCMC central limit theorem, wherein a quantity known as the effective sample size plays the role of the effective sample size in pure Monte Carlo estimation. The effective sample size is determined by how autocorrelated the draws are; if each draw is highly correlated with previous draws, then more draws are required to achieve the same effective sample size.</p>
<p>Stan is able to calculate the effective sample size for its MCMC methods and use that to estimate standard errors for all of its predictive quantities, such as parameter and event probability estimates.</p>
<p>A fitted Stan object contains a sequence of <span class="math inline">\(M\)</span> draws, where each draw contains a value for every parameter (and generated quantity) in the model. If the computation has converged, as measured by built-in convergence diagnostics, the draws are from the posterior distribution of our parameters conditioned on the observed data. These are draws from the joint posterior distribution; correlation between parameters is likely to be present in the joint posterior even if it was not present in the priors.</p>
</div>
</div>
<div id="model-inspection" class="section level3">
<h3><span class="header-section-number">2.1.4</span> Model inspection</h3>
<p>To address questions 1 and 2 above, we need to examine the parameter draws from the model to check for a few common problems:</p>
<ul>
<li><strong>Lack of mixing</strong>. A poorly “mixing” Markov chain is one that moves very slowly between regions of the parameter space or barely moves at all. This can happen if the distribution of proposals is much narrower than the target (posterior) distribution or if it is much wider than the target distribution. In the former case most proposals will be accepted but the Markov chain will not explore the full parameter space whereas in the latter case most proposals will be rejected and the chain will stall. By running several Markov chains from different starting values we can see if each chain mixes well and if the chains are converging on a common distribution. If the chains don’t mix well then it’s unlikely we’re sampling from a well specified posterior. The most common reason for this error is a poorly specified model.</li>
<li><strong>Stationarity</strong>. Markov chains should be covariance stationary, which means that the mean and variance of the chain should not depend on when you draw the observations. Non-stationarity is normally the consequence of a poorly specified model or an insufficient number of iterations.</li>
<li><strong>Autocorrelation</strong>. Especially in poorly specified or weakly identified models, a given draw of parameters can be highly dependent on the previous draw of the parameters. One consequence of autocorrelation is that the posterior draws will contain less information than the number of draws suggests. That is, the effective posterior sample size will be much less than the actual posterior sample size. For example, 2000 draws with high autocorrelation will be less informative than 2000 independent draws. Assuming the model is specified correctly, then <em>thinning</em> (keeping only every k-th draw) is one common approach to dealing with highly autocorrelated draws. However, while thinning can reduce the autocorrelation in the draws that are retained it still sacrifices information. If possible, <a href="http://mc-stan.org/documentation/">reparameterising the model</a> is a better approach to this problem. (See section 21 of the manual, on Optimizing Stan code).</li>
<li><strong>Divergent transitions</strong>. In models with very curved or irregular posterior densities, we often get “divergent transitions”. This typically indicates that the sampler was unable to explore certain regions of the distribution and a respecification or changes to the sampling routine may be required. The easiest way of addressing this issue is to use <code>control = list(adapt_delta = 0.99)</code> or some other number close to 1. This will lead to smaller step sizes and therefore more steps will be required to explore the posterior. Sampling will be slower but the algorithm will often be better able to explore these problematic regions, reducing the number of divergent transitions.</li>
</ul>
<p>All of these potential problems can be checked using the ShinyStan graphical interface, which is available in the <code>shinystan</code> <code>R</code> package. You can install it with <code>install.packages(&quot;shinystan&quot;)</code>, and run it with <code>launch_shinystan(correct_fit)</code>. It will bring up an interactive session in your web browser within which you can explore the estimated parameters, examine the individual Markov chains, and check various diagnostics. More information on ShinyStan is available <a href="http://mc-stan.org/interfaces/shinystan">here</a>. We will confront most of these issues and show how to resolve them in later chapters when we work with real examples. For now just keep in mind that MCMC samples always need to be checked before they are used for making inferences.</p>
</div>
<div id="taking-the-model-to-real-data" class="section level3">
<h3><span class="header-section-number">2.1.5</span> Taking the model to real data</h3>
<p>Now we have fit the model to some fake data and successfully been able to recover “known unknowns”, we can fit the model to our real data.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set up our data</span>

compiled_model &lt;-<span class="st"> </span><span class="kw">stan_model</span>(<span class="st">&quot;ar_model_missing.stan&quot;</span>)</code></pre></div>
<pre><code>## In file included from file7bf404c3e6d.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:12:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/gevv_vvv_vari.hpp:5:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/var.hpp:7:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/math/tools/config.hpp:13:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/config.hpp:39:
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/config/compiler/clang.hpp:196:11: warning: &#39;BOOST_NO_CXX11_RVALUE_REFERENCES&#39; macro redefined [-Wmacro-redefined]
## #  define BOOST_NO_CXX11_RVALUE_REFERENCES
##           ^
## &lt;command line&gt;:6:9: note: previous definition is here
## #define BOOST_NO_CXX11_RVALUE_REFERENCES 1
##         ^
## In file included from file7bf404c3e6d.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:42:
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/set_zero_all_adjoints.hpp:14:17: warning: unused function &#39;set_zero_all_adjoints&#39; [-Wunused-function]
##     static void set_zero_all_adjoints() {
##                 ^
## In file included from file7bf404c3e6d.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core.hpp:43:
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/core/set_zero_all_adjoints_nested.hpp:17:17: warning: &#39;static&#39; function &#39;set_zero_all_adjoints_nested&#39; declared in header file should be declared &#39;static inline&#39; [-Wunneeded-internal-declaration]
##     static void set_zero_all_adjoints_nested() {
##                 ^
## In file included from file7bf404c3e6d.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:11:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/prim/mat.hpp:59:
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/prim/mat/fun/autocorrelation.hpp:17:14: warning: function &#39;fft_next_good_size&#39; is not needed and will not be emitted [-Wunneeded-internal-declaration]
##       size_t fft_next_good_size(size_t N) {
##              ^
## In file included from file7bf404c3e6d.cpp:8:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/src/stan/model/model_header.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math.hpp:4:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/rev/mat.hpp:11:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/prim/mat.hpp:298:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/prim/arr.hpp:39:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/StanHeaders/include/stan/math/prim/arr/functor/integrate_ode_rk45.hpp:13:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/numeric/odeint.hpp:61:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/numeric/odeint/util/multi_array_adaption.hpp:29:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array.hpp:21:
## In file included from /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array/base.hpp:28:
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:42:43: warning: unused typedef &#39;index_range&#39; [-Wunused-local-typedef]
##       typedef typename Array::index_range index_range;
##                                           ^
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:43:37: warning: unused typedef &#39;index&#39; [-Wunused-local-typedef]
##       typedef typename Array::index index;
##                                     ^
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:53:43: warning: unused typedef &#39;index_range&#39; [-Wunused-local-typedef]
##       typedef typename Array::index_range index_range;
##                                           ^
## /Library/Frameworks/R.framework/Versions/3.3/Resources/library/BH/include/boost/multi_array/concept_checks.hpp:54:37: warning: unused typedef &#39;index&#39; [-Wunused-local-typedef]
##       typedef typename Array::index index;
##                                     ^
## 8 warnings generated.</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">KPI_data$kpi_value[<span class="kw">is.na</span>(KPI_data$kpi_value)] &lt;-<span class="st"> </span>-<span class="dv">9</span>

KPI_data$kpi_value[<span class="dv">140</span>:<span class="dv">149</span>] &lt;-<span class="st"> </span>-<span class="dv">9</span>

data_list_real &lt;-<span class="st"> </span><span class="kw">list</span>(<span class="dt">T =</span> <span class="kw">nrow</span>(KPI_data),
                       <span class="dt">P =</span> <span class="dv">7</span>, 
                       <span class="dt">Y_raw =</span> KPI_data$kpi_value,
                       <span class="dt">N_missing =</span> <span class="kw">sum</span>(KPI_data$kpi_value ==<span class="st"> </span>-<span class="dv">9</span>))

model_fit_real &lt;-<span class="st"> </span><span class="kw">sampling</span>(compiled_model, 
                           data_list_real, 
                           <span class="dt">iter =</span> <span class="dv">1000</span>)



<span class="co"># And now we can plot our forecasts! </span>
model_fit_real %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">as.data.frame</span>() %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">select</span>(<span class="kw">contains</span>(<span class="st">&quot;Y[&quot;</span>)) %&gt;%<span class="st"> </span>
<span class="st">  </span>reshape2::<span class="kw">melt</span>() %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">group_by</span>(variable) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">summarise</span>(<span class="dt">lower =</span> <span class="kw">quantile</span>(value, .<span class="dv">25</span>),
            <span class="dt">upper =</span> <span class="kw">quantile</span>(value, .<span class="dv">75</span>),
            <span class="dt">median =</span> <span class="kw">median</span>(value)) %&gt;%
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">actuals =</span> KPI_data$kpi_value,
         <span class="dt">actuals =</span> <span class="kw">ifelse</span>(actuals==-<span class="dv">9</span>, <span class="ot">NA</span>, actuals),
         <span class="dt">date =</span> KPI_data$date) %&gt;%<span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(<span class="dt">x =</span> date)) +
<span class="st">  </span><span class="kw">geom_ribbon</span>(<span class="kw">aes</span>(<span class="dt">ymin =</span> lower, <span class="dt">ymax =</span> upper), <span class="dt">fill =</span> <span class="st">&quot;orange&quot;</span>, <span class="dt">alpha =</span> <span class="fl">0.4</span>) +
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">y =</span> median)) +
<span class="st">  </span>ggthemes::<span class="kw">theme_hc</span>() +
<span class="st">  </span><span class="kw">ggtitle</span>(<span class="st">&quot;Median forecast for our KPI series&quot;</span>)</code></pre></div>
<p><img src="Shortcourse_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
</div>
</div>
<div id="tools-of-the-trade-borrowing-from-software-engineering" class="section level2">
<h2><span class="header-section-number">2.2</span> Tools of the trade: borrowing from software engineering</h2>
<p>Building economic and statistical models increasingly requires sophisticated computation. This has the potential to improve our modeling, but carries with it risks; as the complexity of our models grows, so too does the prospect of making potentially influential mistakes. The well-known spreadsheet error in Rogoff and Reinhart’s (Cite) paper—a fairly simple error in very public paper—was discovered. Who knows how many other errors exist in more complex, less scruitinized work?</p>
<p>Given the ease of making errors that substantively affect our models’ outputs, it makes sense to adopt a workflow that minimizes the risk of such error happening. The set of tools discussed in this section, all borrowed from software engineering, are designed for this purpose. We suggest incorporating the following into your workflow:</p>
<ul>
<li>Document your code formally. At the very least, this will involve commenting your code to the extend where a colleague could read it and not have too many questions. Ideally it will include formal documentation of every function that you write.</li>
<li>When you write functions, obey what we might call “Tinbergen’s rule of writing software”: <em>one function, one objective</em>. Try not to write omnibus functions that conduct a large part of your analysis. Writing small, modular functions will allow you to use <strong>unit testing</strong>, a framework that lets you run a set of tests automatically, ensuring that changing one part of your code base does not break other parts.</li>
<li>Use Git to manage your workflow. Git is a very powerful tool that serves several purposes. It can help you back up your work, which is handy. It also allows you to view your codebase at periods when you <em>committed</em> some code to the code base. It lets you experiment on <em>branches</em>, without risking the main (“production”) code base. Finally helps you work in teams; formalizing a <strong>code-review</strong> procedure that should help catch errors.</li>
</ul>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="intro.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="vsb.html" class="navigation navigation-next " aria-label="Next page""><i class="fa fa-angle-right"></i></a>

<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"download": ["Shortcourse.pdf"],
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
